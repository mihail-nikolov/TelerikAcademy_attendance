#Creational patterns homework

#Singleton

[] Основната идея на Singleton шаблона е singleton класа е той да има точно 1 инстанция, чрез която да се използва и да се достъпва глобално.
[] Целта е спестяване на ресурси и време за инициализация.
[] Начина за използване на шаблона е самия клас да има метод, който инициализира класа (или да връща референция към обекта, ако вече е инициализиан).
[] В този случай трябва да има поле/метод, което да пази инстанцията на класа -> от тука възниква и 1 от проблемите - нарушава се Single responsibility principle:
     * от една страна класа се ползва, за функционалността е предназначен
     * от друга страна класа пази своята единствена инстанция (ако тя вече съществува)
[] За да е сигурно, че класа няма да бъде инстанциран отвън конструктора се прави private.
[] Друг проблем е, че класа трябва да бъде внимателно конструиран при multi-theading applications.
[] Класа е труден за тестване.

#Abstract factoriy

[] Abstract factory pattern-a предоставя интерфейс за създаване на взаимносвързани обекти.
[] Factory само по себе си представлява метод за създаване на обекти, като идеята е бъде изолирано създаването от използването на конкретните обекти.
[] Abstract factory class-a капсулира група от методи Factroy с близко предназначение. 
По този начин на клиента не му е нужно да знае как се ползва всеки клас поотделно.Той използва само основния интерфейс.(Клиента не го интересува коя пицария ще му направи пицата, той просто я иска доставена :).
[] Abstract factory pattern-a позволява замяната на конкретни класове, дори по време на изпълнение, без да е нужна промяна на кода, който ги използва. 
Това обаче е за сметка на допълнително усложняване на кода, което от своя страна не е много желателно.


#Builder
[] Използва се, когато има многостъпково създаване на обект и последователността на тези стъпки е важна.
[] Работи се с "director", който знае за логиката, стъпките на създаване на отделните части на обекта. Director-а работи с "builder interface".
[] Самия "director" не го интересува какво точно се случва във всяка от тези стъпки - за това знае "concrete builder" (той ги имплементира), a "builder interface" ги дефинира.
[] Имаме разделяне на отговорности.
