<h1>Behavioral patterns homework</h1>

<h2>Template method</h2>
<ul>		
<li> Дефинира скелет на алгоритъм в метод (наречен "template method"), което полага стъпките за класовте наследници</li>
<li> Позволява на наследниците да предефинират определени стъпки от алгоритъм, без да променят скелета на метода</li>
<li> В "template method" на този design pattern, алгоритмични стъпки могат да бъдат презаписани от наследниците, като се осигурява, че алгоритъма се спазва.</li>
<li> В ООП, първо се създава клас, който дефинира основните стъпки на "template method"-a</li>
<li> Тези стъпки са имплементирани чрез абстрактни методи. По - нататък наследниците променят abstract method-ите, за да имплементират реални действия</li>
<li> Основния алгоритъм се пази само на 1 място, но конкретните стъпки могат да бъдат имплементирани в наследниците</li>
<li> Абстрактния клас може да дефинира абстрактни "virtual method", който може да бъде презаписан. Това позволява свобода на наследниците - могат да го използват в основния му вид, но могат и да го презапишат</li>
</ul>

<h2>Visitor</h2>
<ul>
<li>Позволява начин да дефинираме нови фунционалности на клас, без да променяме елементите му - това улеснява да се следва OCP</li>
<li>Всъщност visitor позволява да бъдат добавяни virtual methods на фамилия от класове, без да се модифицират самите класове</li>
<li>Осъществява се като се създава visitor class, който имплементира цялата необходима virtual functions </li>
<li>Visitor class взима референция към инстанцията и имплементира необходимата функционалност чрез double dispatch</li>
<li>Този pattern е много добър при нужда на добаваняне на фунцкионалности в публични API-та, чрез visitor class, като не се налага да се модифицира sourcе-а</li>

</ul>

<h2>Strategy</h2>
<ul>
<li>Позволява алгоритъма да бъде селектиран по време на изпълнение.</li>
<li>Дефинира група от алгоритми.</li>
<li>Енкапсулира всеки алгоритъм</li>
<li>Позволява алгоритъма да се променя независимо от клиентите, които го ползват</li>
<li>Много добър пример за използването на pattern-a е използването му за валидация на обекти. В повечето случаи начина, по който се валидират данните не се знае до момента на run-time и често се налага да използване на коренно различна валидация. Validation стратегиите(капсулирани отделно от валидиращия обект) могат да бъдат използвани от друг валидиращ обект в различни части на системата, като се спазва DRY принципа</li>
</ul>

<h2>Mediator</h2>
<ul>
<li>Дефинира обект (среда), който капсулира начина, по който други обекти си комуникират</li>
<li>Повечето програми са създадени от голям брой класове и колкото по - голям е броя им толкова по - сложна става комуникацията между отделните обекти. Това води до усложнено четене и поддръжка.</li>
<li>Също така прави много сложно, или почти невъзможна подмяната на дадена част от програмата, защото това би повлияло на много голяма част от останалия код.</li>
<li>Чрез този pattern тази комуникация се осъществява в mediator object. Отделните обекти вече не комуникират директно, а чрез mediator object-a</li>
<li>Това намалява зависимостите между отделните класове => намалява coupling-а</li>
</ul>