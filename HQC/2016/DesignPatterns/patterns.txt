Design patterns:

===========================================================================================================================================
Creational Patterns:

-------------------------------------------------------------------------------------------------------------------------------------------
Singleton
	Основната идея на Singleton шаблона е singleton класа е той да има точно 1 инстанция, чрез която да се използва и да се достъпва глобално.
	Целта е спестяване на ресурси и време за инициализация.
	Начина за използване на шаблона е самия клас да има метод, който инициализира класа (или да връща референция към обекта, ако вече е инициализиан).
	В този случай трябва да има поле/метод, което да пази инстанцията на класа -> от тука възниква и 1 от проблемите -
	нарушава се Single responsibility principle:
	     от една страна класа се ползва, за функционалността е предназначен
	     от друга страна класа пази своята единствена инстанция (ако тя вече съществува)
	За да е сигурно, че класа няма да бъде инстанциран отвън конструктора се прави private.
	Друг проблем е, че класа трябва да бъде внимателно конструиран при multi-theading applications.
	Класа е труден за тестване.

-------------------------------------------------------------------------------------------------------------------------------------------
Lazy initialization - lazy evaluation (linq)

-------------------------------------------------------------------------------------------------------------------------------------------
Simple Factory:
with reflecatioN:

	public class Factory
	{
	    private static IDictionary<string, Type> registeredTypes 
	                        = new Dictionary<string, Type>();

	    public static void Register<T>(string typeId)
	    {
	        var type = typeof(T);
	        if(type.IsAbstract || type.IsInterface)
	            throw new ArgumentException(
	        "Cannot create abstract type " + type.Name);

	        registeredTypes.Add(typeId, type);
	    }

	    public static T Create<T>(string id, params object[] parameters)
	    {
	        Type typeToCreate;
	        if(!registeredTypes.TryGetValue(id, out typeToCreate))
	            throw new NotSupportedException(
	        "Type with id [" + id + "] is not registered.");

	        return (T)Activator.CreateInstance(typeToCreate, parameters);
	    }
	}

-------------------------------------------------------------------------------------------------------------------------------------------
Factory Method:

	public abstract class M16
	{
	    private Scope scope = this.CreateScope();
	    private Camouflage camo = this.CreateCamo();

	    public double Mass { /* return the mass of the rifle */ }

	    public void ShootAtTarget(Point3D targetPosition)
	    {
	        // Very complicated calculation taking account 
	        // of lots of variables such as
	        // scope accuracy and gun weight.
	    }

	    // use virtual methods if defaults are needed
	    protected abstract Scope CreateScope();
	    protected abstract Camouflage CreateCamo();
	}

-------------------------------------------------------------------------------------------------------------------------------------------
Abstract factory:

	Abstract factory pattern-a предоставя интерфейс за създаване на взаимносвързани обекти.
	Factory само по себе си представлява метод за създаване на обекти, като идеята е бъде изолирано създаването от използването на конкретните обекти.
	Abstract factory class-a капсулира група от методи Factroy с близко предназначение. 
	По този начин на клиента не му е нужно да знае как се ползва всеки клас поотделно.Той използва само основния интерфейс.(Клиента не го интересува коя пицария ще му направи пицата, той просто я иска доставена :).
	Abstract factory pattern-a позволява замяната на конкретни класове, дори по време на изпълнение, без да е нужна промяна на кода, който ги използва. 
	Това обаче е за сметка на допълнително усложняване на кода, което от своя страна не е много желателно.


	interface IContinentFactory { // AbstractFactory
	   Herbivore CreateHerbivore();
	   Carnivore CreateCarnivore();
	}
	class AfricaFactory : IContinentFactory {
	   public Herbivore CreateHerbivore() {
	      return new Wildbeаst();
	   }
	   public Carnivore CreateCarnivore() {
	      return new Lion(); // Constructor can be internal
	   }
	}
	class AmericaFactory : IContinentFactory {
	    public Herbivore CreateHerbivore() {
	        return new Bison();
	    }
	    public Carnivore CreateCarnivore() {
	        return new Wolf();
	    }
	}


===========================================================================================================================================
Structural Patterns:

-------------------------------------------------------------------------------------------------------------------------------------------
Adapter
		
 Използва се, когато е необходимо съществуващите класове да работят с най - често нови, без да се променя имплемментацията им.
 Самият адаптер представлява клас, който позволява 2 класа (които не могат да работят директно 1 с друг) да работят заедно
 Осъществява се като конвертира интерфейса на 1 клас към такъв, какъвто 2рия очаква.

-------------------------------------------------------------------------------------------------------------------------------------------
Facade

Предоставя опростен интерфейс от по - голям набор от код
Най - често се използва, когато системата е много сложна и съдържа голям набор от различни метода, извикани от различни класове
Идеята е да се постигне по - голяма абстракция и цялата сложност на операциите да бъде скрита зад конкретния клас, интерфейс(фасада). 


-------------------------------------------------------------------------------------------------------------------------------------------
Decorator

Използва се, когато е необходимо на даден обект да бъде добавена фунционалност(статични или динамично)без да се засяга основния клас.
Полезен е, когато е искаме да се придържаме към SRP.
Позволява използването на няколко декоратора (добавяне на различни фунционалности "една върху друга)
Трябва да се има предвид, че самите декоратори и базовия клас трябва да имат общи методи, които в общия случай се override-ват
Обикновено декоратор-методите са дефинирани в интерфейс, който се наследява от декоратор-класовете и базовия клас


-------------------------------------------------------------------------------------------------------------------------------------------
Composite pattern - примера с дървото.. действието да се извършва върху 1 обект, а той да го извършва върху много. Обекта да може да съдържа лист
с инстанции от същия тип

Proxy - накратко... някакви тежки неща не се ползват, докато не са нужни. Клиента ползва proxy-то, а то преценява кога да ползва извика и ползва
по - тежкия обект

===========================================================================================================================================
Behavioral Patterns:

-------------------------------------------------------------------------------------------------------------------------------------------
Template method
		
 Дефинира скелет на алгоритъм в метод (наречен "template method"), което полага стъпките за класовте наследници
 Позволява на наследниците да предефинират определени стъпки от алгоритъм, без да променят скелета на метода
 В "template method" на този design pattern, алгоритмични стъпки могат да бъдат презаписани от наследниците, като се осигурява, че алгоритъма се спазва.
 В ООП, първо се създава клас, който дефинира основните стъпки на "template method"-a
 Тези стъпки са имплементирани чрез абстрактни методи. По - нататък наследниците променят abstract method-ите, за да имплементират реални действия
 Основния алгоритъм се пази само на 1 място, но конкретните стъпки могат да бъдат имплементирани в наследниците
 Абстрактния клас може да дефинира абстрактни "virtual method", който може да бъде презаписан. Това позволява
 свобода на наследниците - могат да го използват в основния му вид, но могат и да го презапишат


-------------------------------------------------------------------------------------------------------------------------------------------
Strategy

Примера със Sort

Позволява алгоритъма да бъде селектиран по време на изпълнение.
Дефинира група от алгоритми.
Енкапсулира всеки алгоритъм
Позволява алгоритъма да се променя независимо от клиентите, които го ползват
Много добър пример за използването на pattern-a е използването му за валидация на обекти. В повечето случаи начина, по който се
валидират данните не се знае до момента на run-time и често се налага
 да използване на коренно различна валидация. Validation стратегиите(капсулирани отделно от валидиращия обект) 
 могат да бъдат използвани от друг валидиращ обект в различни части на системата, като се спазва DRY принципа


-------------------------------------------------------------------------------------------------------------------------------------------
Observer

-------------------------------------------------------------------------------------------------------------------------------------------
Mediator

Дефинира обект (среда), който капсулира начина, по който други обекти си комуникират
Повечето програми са създадени от голям брой класове и колкото по - голям е броя им толкова по - сложна става комуникацията между отделните обекти. Това води до усложнено четене и поддръжка.
Също така прави много сложно, или почти невъзможна подмяната на дадена част от програмата, защото това би повлияло на много голяма част от останалия код.
Чрез този pattern тази комуникация се осъществява в mediator object. Отделните обекти вече не комуникират директно, а чрез mediator object-a
Това намалява зависимостите между отделните класове => намалява coupling-а


-------------------------------------------------------------------------------------------------------------------------------------------
Memento - само да помним, че понякога се налага да се пази момментно състояние на даден обект, и това трябва да се прави от някой клас извън него

-------------------------------------------------------------------------------------------------------------------------------------------
Specifications (Rules) pattern - And/Or/Not нещата - методи за сравнение на обекти